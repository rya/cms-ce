/*
 * Copyright 2000-2011 Enonic AS
 * http://www.enonic.com/license
 */
package com.enonic.cms.framework.jdbc.delegate;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

/**
 * This class implements the delegating statement.
 */
public class DelegatingStatement
    extends DelegatingBase
    implements Statement
{
    /**
     * Connection.
     */
    private final Connection conn;

    /**
     * Real statement.
     */
    private final Statement stmt;

    /**
     * Construct the statement.
     */
    public DelegatingStatement( Statement stmt, Connection conn )
    {
        this.conn = conn;
        this.stmt = stmt;
    }

    /**
     * Return the delegate.
     */
    public Object getDelegate()
    {
        return this.stmt;
    }

    public int getFetchDirection()
        throws SQLException
    {
        return stmt.getFetchDirection();
    }

    public int getFetchSize()
        throws SQLException
    {
        return stmt.getFetchSize();
    }

    public int getMaxFieldSize()
        throws SQLException
    {
        return stmt.getMaxFieldSize();
    }

    public int getMaxRows()
        throws SQLException
    {
        return stmt.getMaxRows();
    }

    public int getQueryTimeout()
        throws SQLException
    {
        return stmt.getQueryTimeout();
    }

    public int getResultSetConcurrency()
        throws SQLException
    {
        return stmt.getResultSetConcurrency();
    }

    public int getResultSetHoldability()
        throws SQLException
    {
        return stmt.getResultSetHoldability();
    }

    public int getResultSetType()
        throws SQLException
    {
        return stmt.getResultSetType();
    }

    public int getUpdateCount()
        throws SQLException
    {
        return stmt.getUpdateCount();
    }

    public void cancel()
        throws SQLException
    {
        stmt.cancel();
    }

    public void clearBatch()
        throws SQLException
    {
        stmt.clearBatch();
    }

    public void clearWarnings()
        throws SQLException
    {
        stmt.clearWarnings();
    }

    public void close()
        throws SQLException
    {
        stmt.close();
    }

    public boolean getMoreResults()
        throws SQLException
    {
        return stmt.getMoreResults();
    }

    public int[] executeBatch()
        throws SQLException
    {
        return stmt.executeBatch();
    }

    public void setFetchDirection( int direction )
        throws SQLException
    {
        stmt.setFetchDirection( direction );
    }

    public void setFetchSize( int rows )
        throws SQLException
    {
        stmt.setFetchSize( rows );
    }

    public void setMaxFieldSize( int max )
        throws SQLException
    {
        stmt.setMaxFieldSize( max );
    }

    public void setMaxRows( int max )
        throws SQLException
    {
        stmt.setMaxRows( max );
    }

    public void setQueryTimeout( int seconds )
        throws SQLException
    {
        stmt.setQueryTimeout( seconds );
    }

    public boolean getMoreResults( int current )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public void setEscapeProcessing( boolean enable )
        throws SQLException
    {
        stmt.setEscapeProcessing( enable );
    }

    public int executeUpdate( String sql )
        throws SQLException
    {
        return stmt.executeUpdate( sql );
    }

    public void addBatch( String sql )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public void setCursorName( String name )
        throws SQLException
    {
        stmt.setCursorName( name );
    }

    public boolean execute( String sql )
        throws SQLException
    {
        return stmt.execute( sql );
    }

    public int executeUpdate( String sql, int autoGeneratedKeys )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public boolean execute( String sql, int autoGeneratedKeys )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public int executeUpdate( String sql, int[] columnIndexes )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public boolean execute( String sql, int[] columnIndexes )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public Connection getConnection()
        throws SQLException
    {
        return this.conn;
    }

    public ResultSet getGeneratedKeys()
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public ResultSet getResultSet()
        throws SQLException
    {
        return getResultSet( true );
    }

    public SQLWarning getWarnings()
        throws SQLException
    {
        return stmt.getWarnings();
    }

    public int executeUpdate( String sql, String[] columnNames )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public boolean execute( String sql, String[] columnNames )
        throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public ResultSet executeQuery( String sql )
        throws SQLException
    {
        return executeQuery( sql, true );
    }

    /**
     * Return a wrapped result set if wrapped is set.
     */
    private ResultSet getResultSet( boolean wrapped )
        throws SQLException
    {
        ResultSet rs;
        if ( this.stmt instanceof DelegatingStatement )
        {
            rs = ( (DelegatingStatement) this.stmt ).getResultSet( wrapped );
        }
        else
        {
            rs = this.stmt.getResultSet();
        }

        if ( ( rs != null ) && wrapped )
        {
            return createWrappedResultSet( rs );
        }
        else
        {
            return rs;
        }
    }

    /**
     * Return a wrapped result set if wrapped is set.
     */
    private ResultSet executeQuery( String sql, boolean wrapped )
        throws SQLException
    {
        ResultSet rs;
        if ( this.stmt instanceof DelegatingStatement )
        {
            rs = ( (DelegatingStatement) this.stmt ).executeQuery( sql, wrapped );
        }
        else
        {
            rs = this.stmt.executeQuery( sql );
        }

        if ( ( rs != null ) && wrapped )
        {
            return createWrappedResultSet( rs );
        }
        else
        {
            return rs;
        }
    }

    /**
     * Create wrapped result set.
     */
    protected ResultSet createWrappedResultSet( ResultSet rs )
    {
        return new DelegatingResultSet( rs, this );
    }

    public <T> T unwrap( Class<T> iface )
        throws SQLException
    {
        return this.stmt.unwrap( iface );
    }

    public boolean isWrapperFor( Class<?> iface )
        throws SQLException
    {
        return this.stmt.isWrapperFor( iface );
    }

    public boolean isClosed()
        throws SQLException
    {
        return this.stmt.isClosed();
    }

    public void setPoolable( boolean poolable )
        throws SQLException
    {
        this.stmt.setPoolable( poolable );
    }

    public boolean isPoolable()
        throws SQLException
    {
        return this.stmt.isPoolable();
    }
}
